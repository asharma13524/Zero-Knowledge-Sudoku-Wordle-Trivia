import { compile, acir_from_bytes } from '@noir-lang/noir_wasm';
import { setup_generic_prover_and_verifier, create_proof, verify_proof } from '@noir-lang/barretenberg/dest/client_proofs';
import { BarretenbergWasm } from '@noir-lang/barretenberg/dest/wasm';
import { SinglePedersen } from '@noir-lang/barretenberg/dest/crypto';
import { resolve } from 'path';
import { expect } from 'chai';
import { ethers } from "hardhat";
import { Contract, ContractFactory, utils } from 'ethers';
import { numToHex } from '../utils';

describe('Wordle solidity verifier', function () {
  let barretenberg: BarretenbergWasm;
  let pedersen: SinglePedersen;
  let Verifier: ContractFactory;
  let verifierContract: Contract;

  before(async () => {
    barretenberg = await BarretenbergWasm.new();
    pedersen = new SinglePedersen(barretenberg);
    Verifier = await ethers.getContractFactory("WordleVerifier");
    verifierContract = await Verifier.deploy();
  });

  it("Should verify correct guess result with a mix of correct and incorrect guesses using proof generated by typescript wrapper", async () => {   
    const compiled_program = compile(resolve(__dirname, '../circuits/wordle/src/main.nr'));
    let acir = compiled_program.circuit;
    const abi = compiled_program.abi;

    abi.solution = [1, 2, 3, 4, 5];
    const solution_buffer = pedersen.compressInputs(abi.solution.map((e: number) => Buffer.from(numToHex(e), 'hex')));
    abi.solution_hash = `0x${solution_buffer.toString('hex')}`;
    abi.guess = [1, 2, 4, 3, 6];
    abi.guess_result = [3, 3, 2, 2, 1];

    let [prover, verifier] = await setup_generic_prover_and_verifier(acir);

    const proof = await create_proof(prover, acir, abi);

    const verified = await verify_proof(verifier, proof);
    expect(verified).eq(true);

    const sc_verified = await verifierContract.verify(proof);
    expect(sc_verified).eq(true)
  });  

  it("Should verify correct guess result with all correct guess using proof generated by typescript wrapper", async () => {   
    const compiled_program = compile(resolve(__dirname, '../circuits/wordle/src/main.nr'));
    let acir = compiled_program.circuit;
    const abi = compiled_program.abi;

    abi.solution = [1, 2, 3, 4, 5];
    const solution_buffer = pedersen.compressInputs(abi.solution.map((e: number) => Buffer.from(numToHex(e), 'hex')));
    abi.solution_hash = `0x${solution_buffer.toString('hex')}`;
    abi.guess = [1, 2, 3, 4, 5];
    abi.guess_result = [3, 3, 3, 3, 3];

    let [prover, verifier] = await setup_generic_prover_and_verifier(acir);

    const proof = await create_proof(prover, acir, abi);
    
    const verified = await verify_proof(verifier, proof);
    expect(verified).eq(true);

    const sc_verified = await verifierContract.verify(proof);
    expect(sc_verified).eq(true)
  });  

  it("Should fail on incorrect guess result using proof generated by typescript wrapper", async () => {   
    const compiled_program = compile(resolve(__dirname, '../circuits/wordle/src/main.nr'));
    let acir = compiled_program.circuit;
    const abi = compiled_program.abi;

    abi.solution = [1, 2, 3, 4, 5];
    const solution_buffer = pedersen.compressInputs(abi.solution.map((e: number) => Buffer.from(numToHex(e), 'hex')));
    abi.solution_hash = `0x${solution_buffer.toString('hex')}`;
    abi.guess = [1, 2, 4, 3, 6];
    abi.guess_result = [1, 3, 2, 2, 1];

    let [prover, verifier] = await setup_generic_prover_and_verifier(acir);

    const proof = await create_proof(prover, acir, abi);
    
    const verified = await verify_proof(verifier, proof);
    expect(verified).eq(false);

    await expect(verifierContract.verify(proof)).to.be.revertedWith('Proof failed');
  });

});